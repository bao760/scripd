-- SDVT SAB Safe Auto-Move + Manual Tool Activation
-- Uses PathfindingService + Humanoid:MoveTo for movement (no tween teleport)
-- When arriving at a point, shows a big UI button "K√≠ch ho·∫°t Tool 2" for the user to press manually.
-- Does NOT auto-click, does NOT simulate input. UI button performs Activate() only when clicked.

-- Load Rayfield (classic)
local ok, Rayfield = pcall(function() return loadstring(game:HttpGet('https://sirius.menu/rayfield'))() end)
if not ok or not Rayfield then
    warn("Rayfield load failed.")
    return
end

local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local player = Players.LocalPlayer

-- Window
local Window = Rayfield:CreateWindow({
    Name = "SDVT SAB - Safe AutoMove",
    LoadingTitle = "SDVT Hub",
    LoadingSubtitle = "Safe Auto-Move + Manual Tool Use"
})

-- Tabs
local InfoTab = Window:CreateTab("üìú Info", 4483362458)
local MainTab = Window:CreateTab("üß≠ Main", 4483362458)
local EventTab = Window:CreateTab("üéØ Event", 4483362458)
local ControlTab = Window:CreateTab("‚öôÔ∏è Control", 4483362458)

-- Info
InfoTab:CreateSection("üë§ Player")
InfoTab:CreateLabel("Name: " .. tostring(player.Name))
InfoTab:CreateLabel("UserId: " .. tostring(player.UserId))
InfoTab:CreateLabel("GameId: " .. tostring(game.PlaceId))

-- Points (your coords)
local GO_POINTS = {
    Vector3.new(-325.63, -6.39, 58.34),  -- Go #1
    Vector3.new(-377.17, -6.98, 183.61), -- Go #2
    Vector3.new(-320.29, -6.99, 171.93)  -- Go #3
}

-- Utility: draw simple neon path (visual only)
local function drawPath(waypoints)
    local parts = {}
    for i = 1, #waypoints-1 do
        local p1 = waypoints[i].Position
        local p2 = waypoints[i+1].Position
        local dist = (p1 - p2).Magnitude
        local mid = (p1 + p2) / 2
        local part = Instance.new("Part")
        part.Anchored = true
        part.CanCollide = false
        part.Material = Enum.Material.Neon
        part.Color = Color3.fromRGB(0, 200, 120)
        part.Size = Vector3.new(0.2, 0.2, math.max(0.4, dist))
        part.CFrame = CFrame.new(mid, p2) * CFrame.new(0, 0, -dist/2)
        part.Transparency = 0.2
        part.Parent = workspace
        table.insert(parts, part)
    end
    return parts
end

local function clearParts(parts)
    for _, p in ipairs(parts) do
        if p and p.Parent then p:Destroy() end
    end
end

-- SafeMove implementation (pathfinding + MoveTo) returns true if arrived
local function SafeMoveTo(destination, timeoutTime)
    timeoutTime = timeoutTime or 18 -- seconds per waypoint fallback
    local char = player.Character or player.CharacterAdded:Wait()
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not humanoid or not hrp then
        Rayfield:Notify({Title="‚ö†Ô∏è L·ªói", Content="Kh√¥ng t√¨m th·∫•y Humanoid ho·∫∑c HRP.", Duration=3})
        return false
    end

    local path = PathfindingService:CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true,
        AgentCanClimb = true
    })
    path:ComputeAsync(hrp.Position, destination)
    if path.Status ~= Enum.PathStatus.Success then
        Rayfield:Notify({Title="‚ö†Ô∏è L·ªói ƒë∆∞·ªùng ƒëi", Content="Kh√¥ng t√¨m ƒë∆∞·ª£c l·ªô tr√¨nh an to√†n.", Duration=3})
        return false
    end

    local waypoints = path:GetWaypoints()
    local visuals = drawPath(waypoints)

    for _, wp in ipairs(waypoints) do
        if wp.Action == Enum.PathWaypointAction.Jump then
            humanoid.Jump = true
        end
        local reached = false
        local conn = humanoid.MoveToFinished:Connect(function(success) if success then reached = true end end)
        humanoid:MoveTo(wp.Position)
        local start = tick()
        while not reached and (tick() - start) < timeoutTime do
            task.wait(0.12)
        end
        if conn then conn:Disconnect() end
        if not reached then
            clearParts(visuals)
            Rayfield:Notify({Title="‚ö†Ô∏è T·∫Øc ƒë∆∞·ªùng", Content="Kh√¥ng th·ªÉ ti·∫øp c·∫≠n waypoint, d·ª´ng.", Duration=3})
            return false
        end
    end

    clearParts(visuals)
    return true
end

-- Creates a big ScreenGui button that user must press to Activate tool in slot 2
local function createActivateButton(onClicked)
    -- place in CoreGui to ensure visible (some executors may restrict CoreGui; fallback to PlayerGui)
    local parentGui = nil
    if pcall(function() return game:GetService("CoreGui") end) then
        parentGui = game:GetService("CoreGui")
    else
        parentGui = player:WaitForChild("PlayerGui")
    end

    -- Remove existing if present
    local existing = parentGui:FindFirstChild("SDVT_ActivateGui")
    if existing then existing:Destroy() end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "SDVT_ActivateGui"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = parentGui

    local btn = Instance.new("TextButton")
    btn.Name = "ActivateToolBtn"
    btn.Size = UDim2.new(0, 420, 0, 90)
    btn.Position = UDim2.new(0.5, -210, 0.85, 0)
    btn.AnchorPoint = Vector2.new(0.5, 0.5)
    btn.Text = "üî¥ K√çCH HO·∫†T TOOL SLOT 2 (NH·∫§N TAY ƒê·ªÇ TH·ª∞C HI·ªÜN)"
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 22
    btn.TextWrapped = true
    btn.BackgroundColor3 = Color3.fromRGB(200, 40, 40)
    btn.TextColor3 = Color3.new(1,1,1)
    btn.Parent = screenGui

    local cancelled = false
    local conn
    conn = btn.MouseButton1Click:Connect(function()
        -- disable button to prevent multi-clicks while action runs
        btn.Active = false
        btn.AutoButtonColor = false
        btn.BackgroundColor3 = Color3.fromRGB(120,120,120)
        pcall(onClicked)
        task.wait(0.6)
        if conn then conn:Disconnect() end
        screenGui:Destroy()
    end)

    return screenGui
end

-- Tries to equip tool from backpack slot 2 (best-effort), then call Activate() when user clicks the UI button
-- Note: This is manual activation ‚Äî user must click the UI button to run this function.
local function equipAndAttemptActivateSlot2()
    local backpack = player:FindFirstChildOfClass("Backpack")
    local char = player.Character
    if not backpack then
        Rayfield:Notify({Title="‚ö†Ô∏è L·ªói", Content="Kh√¥ng th·∫•y Backpack.", Duration=3})
        return
    end

    -- Try to find tool in "slot 2" - Roblox doesn't expose slot index reliably;
    -- we'll attempt to select the second tool in Backpack:FindFirstChildOfClass order
    local tools = {}
    for _, item in ipairs(backpack:GetChildren()) do
        if item:IsA("Tool") then table.insert(tools, item) end
    end

    local toolToUse = nil
    if #tools >= 2 then
        toolToUse = tools[2]
    elseif #tools == 1 then
        toolToUse = tools[1] -- fallback to first
    else
        -- also check character for tools
        for _, item in ipairs(char:GetChildren()) do
            if item:IsA("Tool") then toolToUse = item break end
        end
    end

    if not toolToUse then
        Rayfield:Notify({Title="‚ö†Ô∏è Tool kh√¥ng t√¨m th·∫•y", Content="Kh√¥ng t√¨m th·∫•y Tool trong Backpack/Character.", Duration=4})
        return
    end

    -- equip tool (move to character)
    pcall(function()
        toolToUse.Parent = char
    end)

    -- Try to call Activate() (some tools support it server-side; many require mouse click)
    local success, err = pcall(function()
        if toolToUse and toolToUse.Activate then
            toolToUse:Activate()
        end
    end)
    if success then
        Rayfield:Notify({Title="üîî Tool", Content="ƒê√£ g·ªçi Activate() (n·∫øu API cho ph√©p). N·∫øu tool c·∫ßn click, h√£y b·∫•m chu·ªôt.", Duration=4})
    else
        Rayfield:Notify({Title="‚ö†Ô∏è Tool", Content="G·ªçi Activate() th·∫•t b·∫°i: "..tostring(err), Duration=4})
    end
end

-- Create per-point Go buttons in EventTab: auto-move then show big activation button for manual press
for i, pt in ipairs(GO_POINTS) do
    EventTab:CreateButton({
        Name = ("ü™¶ Go #%d (T·ª± ƒëi an to√†n)"):format(i),
        Callback = function()
            task.spawn(function()
                Rayfield:Notify({Title="üß≠ B·∫Øt ƒë·∫ßu", Content=("Di chuy·ªÉn t·ªõi ƒëi·ªÉm %d..."):format(i), Duration=3})
                local ok = SafeMoveTo(pt)
                if ok then
                    Rayfield:Notify({Title="‚úÖ ƒê√£ ƒë·∫øn", Content=("B·∫°n ƒë√£ t·ªõi ƒëi·ªÉm %d. H√£y nh·∫•n n√∫t K√≠ch ho·∫°t Tool xu·∫•t hi·ªán ƒë·ªÉ d√πng tool 2."):format(i), Duration=5})
                    -- show activate button; user must click it
                    createActivateButton(function() equipAndAttemptActivateSlot2() end)
                else
                    Rayfield:Notify({Title="‚ùå Th·∫•t b·∫°i", Content=("Kh√¥ng th·ªÉ ƒë·∫øn ƒëi·ªÉm %d, ki·ªÉm tra v·ªã tr√≠ ho·∫∑c di chuy·ªÉn th·ªß c√¥ng."):format(i), Duration=4})
                end
            end)
        end
    })
end

-- Control tab: option to run sequence automatically (move sequence only). Activation still requires user click per point.
local runSequenceToggle = ControlTab:CreateToggle({
    Name = "Ch·∫°y tu·∫ßn t·ª± t·ª± ƒë·ªông (ch·ªâ di chuy·ªÉn)",
    Current = false,
    Flag = "RunSequenceToggle"
})

ControlTab:CreateButton({
    Name = "‚ñ∂ B·∫Øt ƒë·∫ßu sequence (Go1->Go2->Go3) (Y√™u c·∫ßu x√°c nh·∫≠n)",
    Callback = function()
        if not runSequenceToggle and not runSequenceToggle.Current then
            -- If toggle exists but false, warn
            Rayfield:Notify({Title="‚ö†Ô∏è Ch∆∞a b·∫≠t toggle", Content="H√£y b·∫≠t 'Ch·∫°y tu·∫ßn t·ª± t·ª± ƒë·ªông' tr∆∞·ªõc khi ch·∫°y.", Duration=4})
            return
        end
        task.spawn(function()
            Rayfield:Notify({Title="‚ñ∂ Sequence", Content="B·∫Øt ƒë·∫ßu ch·∫°y tu·∫ßn t·ª± di chuy·ªÉn (Activate v·∫´n b·∫±ng tay).", Duration=3})
            for idx,pt in ipairs(GO_POINTS) do
                local ok = SafeMoveTo(pt)
                if ok then
                    Rayfield:Notify({Title="‚úÖ ƒê√£ ƒë·∫øn", Content=("ƒê√£ ƒë·∫øn ƒëi·ªÉm %d. Nh·∫•n n√∫t 'K√≠ch ho·∫°t Tool 2' ƒë·ªÉ th·ª±c hi·ªán thao t√°c (b·∫Øt bu·ªôc)."):format(idx), Duration=6})
                    createActivateButton(function() equipAndAttemptActivateSlot2() end)
                    -- wait for user to press button (we'll wait up to a timeout)
                    local waited = 0
                    local pressed = false
                    -- simple method: poll for the GUI existence to be gone (button destroys itself after click)
                    while waited < 60 and player and player.Character do
                        local gui = nil
                        pcall(function() gui = (game:GetService("CoreGui"):FindFirstChild("SDVT_ActivateGui") or player.PlayerGui:FindFirstChild("SDVT_ActivateGui")) end)
                        if not gui then
                            pressed = true
                            break
                        end
                        task.wait(1)
                        waited = waited + 1
                    end
                    -- wait 18s pause as you requested previously
                    task.wait(18)
                else
                    Rayfield:Notify({Title="‚ö†Ô∏è Sequence halted", Content="Sequence d·ª´ng do kh√¥ng th·ªÉ ti·∫øp c·∫≠n ƒëi·ªÉm.", Duration=4})
                    break
                end
            end
            Rayfield:Notify({Title="‚ñ∂ Sequence", Content="Sequence di chuy·ªÉn ho√†n t·∫•t (ho·∫∑c b·ªã d·ª´ng).", Duration=4})
        end)
    end
})

-- Final notify
Rayfield:Notify({Title="SDVT SAB Ready", Content="AutoMove loaded. Tool activation requires manual click for safety.", Duration=5})
